# 4.3 Fibonacci探索
図4.3に示すように不確実な範囲$I\_k = \lbrack x\_{L,k}, x\_{U,k} \rbrack$ 及び 
$I\_k$に位置する$x\_{a,k}, x\_{b,k}$ について考える。
4.2節のように、$f(x\_{a,k}), f(x\_{b,k})$で書かれる、$x\_{a,k}, x\_{b,k}$における$f(x)$の値は、
もし,$f(x\_{a,k}) < f(x\_b,k)$であれば、左側の範囲を
$I\_{k+1}^{L} = \lbrack x\_{L,k}, x\_{b,k} \rbrack\rbrack$として選択するため、

もし,$f(x\_{a,k}) > f(x\_b,k)$であれば、右側の範囲を
$I\_{k+1}^{R} = \lbrack x\_{a,k}, x\_{U,k} \rbrack$ として選択するため、

さもなくば、$f(x\_a, k) = f(x\_b, k)$であれば、$I\_{k+1}^R$と$I\_{k+1}^L$
のどちらかを選択するために使われる。

もし、右の区間$I^R\_{k+1}$が選択された場合、その範囲は最小点を含み、
それに加え、$f(x)$の値は$I^R\_{k+1}$の内点の一点でわかっている、すなわち$x\_{b,k}$の点である。
また$f(x)$が$I^R\_{k+1}$内点の一つ以上の点、つまり$x\_{b, k+1}$の点で評価されるとき、
さらに不確実な区間を縮小するための十分な情報が得られ、そして、上記の処理サイクルは繰り返される。
図4.3で示されるような$I\_{k+2}^L$と$I\_{k+2}^R$の二つの新しい部分区間のうち一つを、
前述のように選択することが可能であり、これが繰り返される。
この方法では、一回の繰り返しに対し関数評価が一つだけしか要求されず、
計算量は二分探索法で要求される計算量と比較して削減されるだろう。

図4.3では

$$I\_k = I\_{k+1}^L + I\_{k+2}^R \tag{4.1}$$

としていて、そして便宜上、同一の区間である場合、

$$I\_{k+1}^L = I\_{k+1}^R = I\_{k+1}$$
$$I\_{k+2}^L = I\_{k+2}^R = I\_{k+2}$$

式$4.1$は

$$I\_k = I\_{k+1} + I\_{k+2} \tag{4.2}$$

という漸化式を与えている。

上記の手順が何回も繰り返されるとき、区間列 $\lbrace I\_1, I\_2, \cdots , I\_n \rbrace$
は次のようにして得られる

$$
\begin{array}{c}
  I\_1 = I\_2 + I\_3 \\\\
  I\_2 = I\_3 + I\_4 \\\\
  \vdots \\\\
  I\_n = I\_{n+1} + I\_{n+2} \\\\
\end{array}
$$

上記の一連の$n$個の方程式では、$n + 2$個の変数があり、そして$I\_1$が初期区間として与えられた時
$n + 1$個の変数が残る。
それゆえに、無限数列は何らかの追加のルールを特定することで作れる。
特に興味深い2つの特殊な順序はFibonacci数列と黄金分割数列である。
Fibonacci数列はこの章で、黄金分割数列は4.4章で考える。

Fibonacci数列は$n+2$回目の繰り返しで零になる範囲、つまり$I\_{n+2} = 0$を仮定することで得られる。
式$4.2$で$k = n$と置けば、次のように書ける。
$$
\begin{array}{c}
I\_{n+1} = I\_n - I\_{n+2} = I\_n \equiv F\_0I\_n \\\\
I\_{n} = I\_{n+1} + I\_{n+2} = I\_n \equiv F\_1I\_n \\\\
I\_{n-1} = I\_n + I\_{n+1} = 2I\_n \equiv F\_2I\_n \\\\
I\_{n-2} = I\_{n-1} + I\_{n} = 3I\_n \equiv F\_3I\_n \\\\
I\_{n-3} = I\_{n-2} + I\_{n-1} = 5I\_n \equiv F\_4I\_n \\\\
I\_{n-4} = I\_{n-3} + I\_{n-2} = 8I\_n \equiv F\_5I\_n \\\\
\vdots \\\\
I\_k = I\_{k+1} + I\_{k+2} = F\_{n - k + 1}I\_n \ \cdots\ (4.3a) \\\\
\vdots \\\\
I\_1 = I\_2 + I\_3 = F\_nI\_n \ \cdots\ (4.3b)
\end{array}
$$

得られた数列、すなわち
$\lbrace1, 1, 2, 3, 5, 8, 13, \cdots \rbrace
 = \lbrace F\_0, F\_1, F\_2, F\_3, F\_4, F\_5, F\_6, \cdots \rbrace
$
の数列は、数学の様々な分野に存在するFibonacci数列として有名である。

それは$F\_0 = F\_1 = 1 $ の下での再帰的な関係によって生まれ、
$ F\_k = F\_{k-1} + F\_{k-2} \ \text{for} \ k \geq 2 \tag{4.4} $
である。

一次元最適化におけるこれの応用はFibonacci探索法である。
この方法の、$n = 6, I\_1 = 100 $で始まり、常に左側の範囲が選択された場合、
つまり最小値が$x = 0$の近傍で存在する場合が、図4.4で描かれている。

もし、繰り返しの回数が$n$になると仮定すると、式$(4.3b)$から、Fibonacci探索は不確実な範囲を
$I\_n = \frac{I\_1}{F\_n} \tag{4.5}$
に縮小する。

例えば、もし$n = 11$なら、$F\_n = 144$ なので、$I\_n$は$I\_1$の値の$1\%$未満の値に縮小される。
これは11回の反復を伴い、各反復に一回の関数の評価が必要になるので、
同じだけの正確さを得るために14回の関数評価が必要な二分探索法に対して、合計11回の関数の評価が必要になる。
事実上Fibonacci探索は二分探索に比べて効率が良い。
それにまた、他の探索法に比べて最も大きな範囲の削減を達成していることも示されている、
そしてしたがって、必要計算量の面においても最も効率的である。

区間のFibonacci数列は$n$が明らかになっている場合のみ得られる。
もし、最適化の目的が規定された許容誤差の範囲で$x^{\ast}$を見つけることの場合、
要求される$n$は式$(4.5)$を用いることで用意に推測できる。
しかしながら、もし目的が$f(x)$の最小値を規定された許容誤差の範囲で見つけることの場合、
問題を解かずに要求される$n$を決めるのは難しくなるだろう。
唯一得られる情報は、もし$f(x)$の最小値が浅く、$f(x)$が解の近傍で急速に変化する場合に、
$n$が小さくなるだろうということである。

上の原理はFibonacci探索を実装するために使われる。初期の最小化値の境界を仮定しよう、
いわゆる$x\_{L,1}$と$x\_{U,1}$である、そして$n$の値が与えられ、$f(x)$の数学的表現が存在する。
この実装には連続した範囲を計算すること、$f(x)$を評価すること、そして適切な範囲を選択することからなっている。

$k$回目の繰り返しでは、$x\_{L,k}, x\_{a,k}, x\_{b,k}, x\_{U,k}, I\_{k+1}$の量と

$f\_{a,k} = f(x\_{a,k}), f\_{b,k} = f(x\_{b,k})$

が分かる、そして、
$x\_{L,k+1}, x\_{a,k+1}, x\_{b,k+1}, x\_{U,k+1}, I\_{k+2}, f\_{a,k+1}, f\_{b,k+1}$の量が必要となる。
$I\_{k+2}$の範囲は

$I\_{k+2} = \frac{F\_{n-k-1}}{F\_{n-k}}I\_{k+1} \tag{4.6}$

のようにして式$(4.3a)$から得られる。

残った量は以下の様にして計算される。

$f\_{a,k} > f\_{b,K}$ならば、$x^{\ast}$は$\lbrack x\_{a,k} , x\_{U,k} \rbrack$ の範囲の中にあり、
従って$x^{\ast}$の境界は
$x\_{L,k+1} = x\_{a,k} \tag{4.7}$
$x\_{b,k+1} = x\_{L,k+1} + I\_{k+2} \tag{4.8}$
の様に更新される。

似たように、新しい範囲の二つの内点、いわゆる$x\_{a,k+1}$と$x\_{b,k+1}$は
それぞれ$x\_{b,k}$と$x\_{L,k+1} + I\_{k+2}$になるだろう。
このように図4.5に示されるように
$x\_{a, k+1} = x\_{a,k} \tag{4.9}$
$x\_{b, k+1} = x\_{L,k+1} + I\_{k+2} \tag{4.10}$
の様に割り当てられる。

$f\_{b,k}$の値は$x\_{a,k+1}$における$f(x)$の値として保持され、$x\_{b,k+1}$での$f(x)$の値は計算される、つまり
$f\_{a,k+1} = f\_{b,k} \tag{4.11}$
$f\_{b,k+1} = f(x\_{b,k+1}) \tag{4.12}$
である。

一方で、$f\_{a,k} < f\_{b,k}$の場合、$x^{\ast}$は$\lbrack x\_{L,k}, x\_{b,k} \rbrack$の範囲の中にある。
この場合では、図4.6で示されるように
$x\_{L,k+1} = x\_{L,k} \tag{4.13}$
$x\_{U,k+1} = x\_{b,k} \tag{4.14}$
$x\_{a,k+1} = x\_{U,k+1} - I\_{k+2} \tag{4.15}$
$x\_{b,k+1} = x\_{a,k} \tag{4.16}$
$f\_{b,k+1} = f\_{a,k} \tag{4.17}$
のように割り当て、
$f\_{a,k+1} = f(x\_{a,k+1}) \tag{4.18}$
のように計算する。

運悪く$f\_{a,k} = f\_{b,k}$の場合、
$x^{\ast}$が$\lbrack x\_{L,k} , x\_{b,k} \rbrack$と$\lbrack x\_{a,k} , x\_{U,k} \rbrack$
のどちらの範囲にも含まれるので
上のどちらかの割り当てが使われる。

上記の手順は図4.7に示されるように、
$$i\_{k+2}　= I\_n$$
の場合、$k=n-2$になるまで繰り返され、
$$ x^\ast = x\_{a,k+1} = x\_{b, k+1} $$
明らかに,最小値はある許容誤差$\pm 1 / F\_n$の間の値に決まるだろう。

$x^\ast$の誤差は、二分探索法の1段階を適用することで二分の一になるだろう。
これは、$\epsilon < 1 / F\_n$の下で、
$$　x^\ast = \begin{cases}
      x\_{a,k+1} + \frac{1}{2F\_n} & \text{if} & f(x\_{a,k+1} + \epsilon ) < f(x\_{a,k+1}) \\\\
      x\_{a,k+1} + \frac{\epsilon}{2} & \text{if} & f(x\_{a,k+1} + \epsilon ) = f(x\_{a,k+1}) \\\\
      x\_{a,k+1} - \frac{1}{2F\_n} & \text{if} & f(x\_{a,k+1} + \epsilon ) > f(x\_{a,k+1}) \\\\
    \end{cases}
$$
と$x^\ast$を定めたときに、点$x=x\_{a,k+a} + \epsilon$で$f(x)$を評価することで達成される。

もし$n$がとても大きい場合、$x\_{a,k}$と$x\_{b,k}$の差はとても小さくなる、
そして$x\_{a,k}$は丸め誤差のために、$x\_{b.k}$を超える可能性がある。
もしこれが起きたとき、信頼できない結果が得られることになる。
そのような適用の場合、
もし丸め誤差が発生すれば、問題を取り除くために、アルゴリズムの中に誤差の検査が組み込まれることになる。
おそらく、$x\_{a,k} \approx x\_{b,K}$であれば、十分な精度が達成されるため、
一つの可能性($x\_{a,k} \approx x\_{b,K}$の場合)がアルゴリズムを終了させるでしょう。

上記の原理は次のアルゴリズムによって構築される。

## アルゴリズム4.1 Fibonacci探索
### Step1
$x\_{L,1},x\_{U,1}$と$n$を入力する

### Step2
式($4,4$)を用いて、$F\_1, F\_2, \dots , F\_n$を計算する

### Step3
$I\_1 = x\_{U,1} -x\_{L,1}$を割り当て、

$
   I\_2 = \frac{F\_{n-1}}{F\_n} I\_1 \ \text(see Eq. (4.6))   \\\\
   x\_{a,1} = x\_{U,1} - I\_2, \  x\_{b,1} = x\_{L,1} + I\_2 \\\\
   f\_{a,1} = f(x\_{a,1}), \  f\_{b,1} = f(x\_{b,1})
$

を計算し、$k = 1$と置く

### Step4
$I\_{k+2}$を式$(4.6)$を用いて計算する。

もし $f\_{a.k} \geq f\_{b,k}$であるとき、$x\_{L,k+1},x\_{U,k+1},x\_{b,k+1},f\_{a,k+1},f\_{b,k+1}$を
式$(4.7)$から$(4.12)$を使って更新する。

さもなくば、もし$f\_{a,k} < f\_{b.k}$であれば式$(4.13)$から$(4.18)$を使って情報を更新する。

### Step5
もし$k = n - 2$または$x\_{a,k+1} > x\_{b,k+1}$であれば、
$x^\ast = x\_{a,k+1}$と$f^\ast = f(x^\ast)$を出力し、終了する。

さもなくば、$k = k + 1$と置き、Step4からの手順を繰り返す。


$x\_{a,k+1} > x\_{b,k+1}$の条件は、
コンピュータを利用した精度での$x\_{a,k+1} \approx x\_{b,k+1}$に、早くなったこと、または、
このアルゴリズムに何らかの誤りがあることを暗示している。
このように、この条件は代替終了基準として用いられる。

